# 기초 트레이닝 (프로그래머스)
기초 트레이닝을 하면서 사용한 함수 모음입니다!
<br><br>

# ✅ 자주 쓰이는 함수 모음

## 1. `zip(_:_:)`
- **설명**: 두 개의 시퀀스를 하나의 튜플 시퀀스로 결합합니다. 각 시퀀스에서 같은 위치의 요소들을 묶어줍니다.
- **사용 예**:
    ```swift
    let str1 = "abc"
    let str2 = "123"
    let zipped = zip(str1, str2)  // 결과: [(a, 1), (b, 2), (c, 3)]
    ```
- **특징**: 두 시퀀스 중 더 짧은 쪽의 길이에 맞춰 결합됩니다.

## 2. `map(_:)`
- **설명**: 시퀀스의 각 요소에 대해 주어진 클로저를 적용한 결과를 새로운 배열로 반환합니다.
- **사용 예**:
    ```swift
    let numbers = [1, 2, 3]
    let squares = numbers.map { $0 * $0 }  // 결과: [1, 4, 9]
    ```
- **특징**: 기존 배열은 변경되지 않고, 변환된 새로운 배열이 반환됩니다.

## 3. `filter(_:)`
- **설명**: 시퀀스의 각 요소에서 주어진 조건을 만족하는 요소만 추출하여 새로운 배열로 반환합니다.
- **사용 예**:
    ```swift
    let numbers = [1, 2, 3, 4, 5]
    let evens = numbers.filter { $0 % 2 == 0 }  // 결과: [2, 4]
    ```

## 4. `reduce(_:_:)`
- **설명**: 시퀀스의 요소들을 하나의 값으로 축약합니다. 초기값을 지정하고, 시퀀스의 각 요소에 대해 클로저를 적용하여 결과를 누적합니다.
- **사용 예**:
    ```swift
    let numbers = [1, 2, 3, 4, 5]
    let sum = numbers.reduce(0) { $0 + $1 }  // 결과: 15
    ```

## 5. `joined()`
- **설명**: 배열의 문자열 요소들을 하나의 문자열로 결합합니다. 배열의 각 요소를 순서대로 연결한 문자열을 반환합니다.
- **사용 예**:
    ```swift
    let words = ["Hello", "World"]
    let sentence = words.joined()  // 결과: "HelloWorld"
    ```
- **옵션**: 구분자를 사용할 수 있습니다. 예: `joined(separator: " ")`

## 6. `prefix(_:)`
- **설명**: 시퀀스의 앞에서부터 지정한 개수만큼의 요소를 추출합니다.
- **사용 예**:
    ```swift
    let numbers = [1, 2, 3, 4, 5]
    let firstThree = numbers.prefix(3)  // 결과: [1, 2, 3]
    ```

## 7. `dropFirst(_:)`
- **설명**: 시퀀스의 앞에서부터 지정한 개수만큼의 요소를 제거하고 나머지를 반환합니다.
- **사용 예**:
    ```swift
    let numbers = [1, 2, 3, 4, 5]
    let afterFirstTwo = numbers.dropFirst(2)  // 결과: [3, 4, 5]
    ```

## 8. `sorted(by:)`
- **설명**: 시퀀스의 요소들을 정렬된 배열로 반환합니다. `by`에 클로저를 전달하여 커스텀 정렬도 가능합니다.
- **사용 예**:
    ```swift
    let numbers = [5, 2, 3, 1, 4]
    let sortedNumbers = numbers.sorted()  // 결과: [1, 2, 3, 4, 5]
    ```

## 9. `contains(_:)`
- **설명**: 시퀀스가 특정 요소를 포함하고 있는지 여부를 확인하여 `true` 또는 `false`를 반환합니다.
- **사용 예**:
    ```swift
    let numbers = [1, 2, 3, 4, 5]
    let hasThree = numbers.contains(3)  // 결과: true
    ```

## 10. `compactMap(_:)`
- **설명**: 시퀀스의 각 요소에 대해 주어진 클로저를 적용하여 **nil**이 아닌 요소들만 반환합니다.
- **사용 예**:
    ```swift
    let numbers = ["1", "2", "three", "4"]
    let validNumbers = numbers.compactMap { Int($0) }  // 결과: [1, 2, 4]
    ```
  <br><br>
# 키워드 별
# ✅ 문자열을 특정 구분자를 기준으로 나누어 배열 반환  
**components(separatedBy:)와 split(separator:)**

| 항목             | `components(separatedBy:)`           | `split(separator:)`           |
| ---------------- | ------------------------------------ | ----------------------------- |
| **구분자**       | 문자열(String) 또는 문자 집합(CharacterSet)을 받을 수 있음 | 단일 문자(Character)          |
| **빈 문자열**    | 구분자가 연속으로 나올 경우 **빈 문자열을 포함**  | 빈 문자열을 **포함하지 않음** |
| **결과 타입**    | `[String]`                           | `[Substring]` (성능 면에서 더 효율적) |
| **사용 범위**    | 구분자가 복잡하거나 여러 종류일 때 유용       | 구분자가 단순한 경우 적합      |  
- separatedBy, separator: 구분 기준 값

<br><br>
# ✅ 문자열 반복 생성
**String(repeating:count:)**
- repeating: 반복할 문자열
- count: 반복할 횟수 (양수 입력/ 0을 넣으면 빈 문자열 반환)

<br><br>
# ✅ 문자열이나 문자의 대소문자를 다루는 프로퍼티와 메서드
| 프로퍼티/메서드  | 설명 |
| ---------------- | ---- |
| **`isUppercase`** | **문자**(`Character`)가 대문자인지 확인하는 프로퍼티. (`Bool` 타입 반환) |
| **`isLowercase`** | **문자**(`Character`)가 소문자인지 확인하는 프로퍼티. (`Bool` 타입 반환) |
| **`lowercased()`** | **문자열**(`String`)을 모두 소문자로 변환하여 반환하는 메서드. |
| **`uppercased()`** | **문자열**(`String`)을 모두 대문자로 변환하여 반환하는 메서드. |

<br><br>
# ✅ 이스케이프 문자
문자열 안에서 따옴표나 백슬래시 같은 특수 문자를 그대로 사용하면 문법 오류가 뜸
| 이스케이프 문자 | 설명 |
| --------------- | ---- |
| `\\`            | **백슬래시** 자체를 표현 |
| `\'`            | **작은 따옴표**를 표현 |
| `\"`            | **큰 따옴표**를 표현 (문자열 안에서 사용) |
| `\n`            | **새 줄(개행)** 문자를 표현 |
| `\t`            | **탭(tab)** 문자를 표현 |
| `\r`            | **캐리지 리턴** 문자를 표현 (보통 새 줄과 함께 사용) |
| `\0`            | **널(null)** 문자를 표현 |
| `\u{n}`         | **유니코드** 문자를 표현 (n은 유니코드 값) |

<br><br>
# ✅ 문자열(String) 자르기
| 방법                        | 설명                                                       | 장점                                          | 단점                                        |
| --------------------------- | ---------------------------------------------------------- | --------------------------------------------- | ------------------------------------------- |
| **`index` 사용**            | 문자열의 특정 인덱스나 범위를 지정해 문자열을 자르는 방법  | 정확한 위치를 조작 가능, 매우 유연            | 코드가 복잡해질 수 있음                    |
| **`components(separatedBy:)`** | 특정 구분자를 기준으로 문자열을 분할                      | 코드가 간결하고 간단한 구분 작업에 적합       | 세밀한 조작이 어려움, 구분자가 필요함       |
| **`prefix(while:)`**         | 특정 조건이 참일 때까지 문자열의 앞부분을 추출             | 조건에 따른 유연한 슬라이싱 가능               | 특정 조건만 사용 가능, 조건이 단순해야 함    |  
- separatedBy: 구분 기준 값
- while: 조건문

<br><br>
# ✅ 원하는 요소 추출/ 제거
| 메서드           | 설명                                               |
| ---------------- | -------------------------------------------------- |
| **`prefix(_:)`**  | 컬렉션의 앞에서부터 지정한 개수만큼의 요소를 추출 |
| **`dropFirst(_:)`** | 컬렉션의 앞에서부터 지정한 개수만큼의 요소를 제거 |  
- _:에는 개수 지정하면 됨

<br><br>
# ✅ 지정한 간격을 사용하여 시퀀스(수열) 생성
1. **stride(from:to:by:) : 끝 값을 포함하지 않는 시퀀스 생성**
   - from: 시작 값.
   - to: 끝 값 (포함되지 않음).
   - by: 간격(양수 또는 음수).
   ```swift
   // 0부터 10까지 2씩 증가하지만, 10은 포함되지 않음
   for number in stride(from: 0, to: 10, by: 2) {
       print(number)
   }
   
   출력:
   0
   2
   4
   6
   8
   ```
  <br><br>
3. **stride(from:through:by:) : 끝 값을 포함하는 시퀀스 생성**
   - from: 시작 값.
   - through: 끝 값 (포함됨).
   - by: 간격(양수 또는 음수).
   ```swift
    // 0부터 10까지 2씩 증가하며, 10도 포함됨
    for number in stride(from: 0, through: 10, by: 2) {
        print(number)
    }

    출력:
    0
    2
    4
    6
    8
    10
   ```
